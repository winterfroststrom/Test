cmdhistory=["(-main nil)\\n  " "(defn render-start [^Graphics2D g]\\n  (doto g\\n    (.setColor Color/BLACK)\\n    (.fillRect 0 0 500 500)\\n    (.setColor Color/RED)\\n    (.drawString \\"Alter\\" 200 100)))\\n" "(defn render-start [^Graphics2D g]\\n  (doto g\\n    (.setColor Color/BLACK)\\n    (.fillRect 0 0 500 500)\\n    (.setColor Color/RED)\\n    (.drawString \\"Alter\\" 230 100)))\\n" "(defn input-start [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:world)))\\n\\n(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:start)))\\n\\n(defn input [^KeyEvent e]\\n  (let [e (.getKeyCode e)]\\n    (condp \= @state\\n      \:start (input-start e)\\n      \:world (input-world e))))\\n" "(defn render-start [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (.setColor Color/BLACK)\\n    (.fillRect 0 0 500 500)\\n    (.setColor Color/RED)\\n    (.drawString \\"Alter\\" 230 100)))\\n" "(defn render-world [^Graphics2D g]\\n  (.clearRect g 0 0 500 500)\\n  (doseq [y (range (count game-map))]\\n    (doseq [x (range (count (game-map 0)))]\\n      (render-tile g (get-in game-map [y x]) \\n                   (* x (tile-dimensions \:x))\\n                   (* y (tile-dimensions \:y))))))\\n" "(defn render-world\\n  ([^Graphics2D g] (render-world g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (+ (* x (tile-dimensions \:x)) offx)\\n                     (+ (* y (tile-dimensions \:y)) offy))))))\\n" "(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g 100 100)\\n    \:battle (render-battle g)))\\n" "(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g 130 130)\\n    \:battle (render-battle g)))\\n" "(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g 160 160)\\n    \:battle (render-battle g)))\\n" "(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g 170 170)\\n    \:battle (render-battle g)))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (+ (* x (tile-dimensions \:x)) offx)\\n                     (+ (* y (tile-dimensions \:y)) offy))))))\\n\\n(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170))))\\n  \\n(defn render-battle [^Graphics2D g]\\n  )\\n\\n(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g)\\n    \:battle (render-battle g)))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 110))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 10))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 110))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170))))\\n" "(defn render-tile-rect [^Graphics2D g tile x y color]\\n  (doto g\\n    (.setColor color)\\n    (.fillRect x y (tile-dimensions \:x) (tile-dimensions \:y))))\\n\\n(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)))\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/RED)\\n    1 (render-tile-rect g tile x y Color/GRAY)))\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render -1 100 100)\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      ;(render -1 100 100)\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-tile -1 100 100)\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170)\\n      (render-tile -1 100 100))))\\n" "(defn tile-position [pos keyword offset]\\n  (+ (* pos (tile-dimensions keyword)) offset))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n" "(defn render-world [^Graphics2D g]\\n  (let [offx 170 offy 170\\n        px (get-in @player [\:position \:x])\\n        py (get-in @player [\:position \:y])]\\n    (doto g\\n      (render-game-map offx offy)\\n      (render-tile -1 \\n                   (tile-position px \:x offx)\\n                   (tile-position py \:y offy)))))\\n" "(update-in @player [\:position \:x] inc)\\n" "(update-in @player [\:position \:x] dec)" "(update-in @player [\:position \:x] dec)\\n" "(defn move [p dx dy]\\n  (comp\\n    (update-in p [\:position \:y] + dy)\\n    (update-in p [\:position \:x] + dx)))\\n" "(move @player 1 1)\\n" "(doc comp)\\n" "(defn move [p dx dy]\\n  (update-in (update-in p [\:position \:x] + dx) [\:position \:y] + dy))\\n\\n(move @player 1 1)\\n" "(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:battle)\\n    KeyEvent/VK_UP (swap\! player move 0 1)\\n    KeyEvent/VK_DOWN (swap\! player move 0 -1)\\n    KeyEvent/VK_LEFT (swap\! player move -1 0)\\n    KeyEvent/VK_RIGHT (swap\! player move 1 0)))\\n" "(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:battle)\\n    KeyEvent/VK_UP (swap\! player move 0 -1)\\n    KeyEvent/VK_DOWN (swap\! player move 0 1)\\n    KeyEvent/VK_LEFT (swap\! player move 1 0)\\n    KeyEvent/VK_RIGHT (swap\! player move -1 0)))\\n" "(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:battle)\\n    KeyEvent/VK_UP (swap\! player move 0 -1)\\n    KeyEvent/VK_DOWN (swap\! player move 0 1)\\n    KeyEvent/VK_LEFT (swap\! player move -1 0)\\n    KeyEvent/VK_RIGHT (swap\! player move 1 0)))\\n" "(def time-delta 200)\\n" "(def time-delta 50)\\n" "(def time-delta 500)\\n" "(def time-delta 1000)\\n" "(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)))\\n" "(def enemey (atom {\:hp 2 \:atk 1}))\\n" "(def player (atom {\:position {\:x 2 \:y 2}\\n                   \:kills 0\\n                   \:stats {\:hp 10 \:atk 2 \:name \:player}}))\\n\\n(def enemey (atom {\:hp 2 \:atk 1 \:name \:enemy}))\\n" "(defn render-stats [^Graphics2D g stats x y]\\n  (doto g\\n    (.drawString (str (stats \:name)) x y)\\n    (.drawString (str (stats \:hp)) x (+ y 20))))\\n\\n(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (@player \:stats) 100 100)\\n    (render-stats @enemy 300 300)))\\n" "(def enemey (atom {\:hp 2 \:atk 1 \:name \:enemy}))\\n" "@enemy" "enemy" "(def enemy (atom {\:hp 2 \:atk 1 \:name \:enemy}))\\n" "(defn render-stats [^Graphics2D g stats x y]\\n  (doto g\\n    (.drawString (str (stats \:name)) x y)\\n    (.drawString (str (stats \:hp)) x (+ y 20))))\\n\\n(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (@player \:stats) 100 100)\\n    (render-stats @enemy 300 300)))\\n" "(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (@player \:stats) 100 100)\\n    (render-stats @enemy 300 100)))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [e] (update-in e [\:hp] dec)))))\\n" "enemy" "((fn [e] (update-in e [\:hp] dec)) @enemy)\\n" "(swap\! enemy (fn [e] (update-in e [\:hp] dec)))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n    ))\\n" "(defn input [^KeyEvent e]\\n  (let [e (.getKeyCode e)]\\n    (condp \= @state\\n      \:start (input-start e)\\n      \:world (input-world e)\\n      \:battle (input-battle e))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n    ))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] dec)))\\n    ))\\n" "(reset\! enemy (make-enemy))" "(defn make-enemy []\\n  {\:hp 2 \:atk 1 \:name \:enemy})\\n" "(reset\! enemy (make-enemy))" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] dec)))\\n    )\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) (reset\! state \:start)\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy)) \\n      (reset\! state \:world))))\\n" "(-main)\\n  " "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)]\\n    (if (valid-position? (get-in np [\:position \:x]) (get-in np [\:position \:y]))\\n      (reset\! p np))))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 0 0 0 0 0 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 0 0 1 1 0 0 0 1]])\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 0 0 0 0 0 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 0 0 0 1]])\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 0 0 0 0 0 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)]\\n    (when (valid-position? (get-in np [\:position \:x]) (get-in np [\:position \:y]))\\n      (reset\! p np)\\n      (when (> (rand 20) 15)\\n        (reset\! state \:battle)))))\\n" "(defn valid-position? [x y]\\n  (not (\= (get-in game-map [y x]) 1)))\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)))\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)\\n    nil))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 0 0 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn try-battle\! [x y]\\n  (when (and (\= (get-in game-map [y x]) 0) (> (rand 20) 15))\\n    (reset\! state \:battle)))\\n\\n(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? )\\n      (reset\! p np x y)\\n      (try-battle\! x y))))\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np x y)\\n      (try-battle\! x y))))\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np)\\n      (try-battle\! x y))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n                    (swap\! player (fn [pl] (update-in pl [\:stats \:hp] dec))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] dec)))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] - (get-in @player [\:stats \:atk]))))\\n                    (swap\! player (fn [pl] (update-in pl [\:stats \:hp]  - (@enemy \:atk)))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] - (get-in @enemy [\:stats \:atk]))))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] - (get-in @player [\:stats \:atk]))))\\n                    (swap\! player (fn [pl] (update-in pl [\:stats \:hp]  - (@enemy \:atk)))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] - (get-in @enemy [\:atk]))))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] - (get-in @player [\:stats \:atk]))))\\n                    (swap\! player (fn [pl] (update-in pl [\:stats \:hp]  - (@enemy \:atk)))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] - (get-in @enemy [\:atk]))))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world)\\n      (swap\! player (fn [pl] (update-in pl [\:kills] inc))))))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (.drawString (str \\"Kills\: \\" (@player \:kills)) 100 100)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (.drawString g (str \\"Kills\: \\" (@player \:kills)) 100 100)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (.drawString g (str \\"Hp\: \\" (get-in @player [\:stats \:hp])) 100 100)\\n    (.drawString g (str \\"Kills\: \\" (@player \:kills)) 100 120)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 3]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)\\n    3 (render-tile-rect g tile x y Color/ORANGE)\\n    nil))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [3 2 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 3]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)\\n    3 (render-tile-rect g tile x y Color/ORANGE)\\n    4 (render-tile-rect g tile x y Color/ORANGE)\\n    nil))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [4 2 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 3]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn move-to [p x y]\\n  (assoc-in (assoc-in p [\:position \:x] x) [\:position \:y] y))\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np)\\n      (cond \\n        (\= (get-in game-map [y x]) 3) (swap\! p move-to 1 2)\\n        (\= (get-in game-map [y x]) 4) (swap\! p move-to 13 7)\\n        \:else (try-battle\! x y)        \\n        ))))\\n" "(def game-map (atom [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [4 2 2 0 1 1 0 0 0 1 1 0 5 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 3]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]]))\\n\\n(defn render-start [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (.setColor Color/BLACK)\\n    (.fillRect 0 0 500 500)\\n    (.setColor Color/RED)\\n    (.drawString \\"Alter\\" 230 100)))\\n\\n(defn render-tile-rect [^Graphics2D g tile x y color]\\n  (doto g\\n    (.setColor color)\\n    (.fillRect x y (tile-dimensions \:x) (tile-dimensions \:y))))\\n\\n(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)\\n    3 (render-tile-rect g tile x y Color/ORANGE)\\n    4 (render-tile-rect g tile x y Color/ORANGE)\\n    5 (render-tile-rect g tile x y Color/BLACK)\\n    6 (render-tile-rect g tile x y Color/WHITE)\\n    nil))\\n\\n(defn tile-position [pos keyword offset]\\n  (+ (* pos (tile-dimensions keyword)) offset))\\n\\n(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (.drawString g (str \\"Hp\: \\" (get-in @player [\:stats \:hp])) 100 100)\\n    (.drawString g (str \\"Kills\: \\" (@player \:kills)) 100 120)\\n    (doseq [y (range (count @game-map))]\\n      (doseq [x (range (count (@game-map 0)))]\\n        (render-tile g (get-in @game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n\\n(defn render-world [^Graphics2D g]\\n  (let [offx 170 offy 170\\n        px (get-in @player [\:position \:x])\\n        py (get-in @player [\:position \:y])]\\n    (doto g\\n      (render-game-map offx offy)\\n      (render-tile -1 \\n                   (tile-position px \:x offx)\\n                   (tile-position py \:y offy)))))\\n  \\n(defn render-stats [^Graphics2D g stats x y]\\n  (doto g\\n    (.drawString (str (stats \:name)) x y)\\n    (.drawString (str (stats \:hp)) x (+ y 20))))\\n\\n(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (@player \:stats) 100 100)\\n    (render-stats @enemy 300 100)))\\n\\n(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g)\\n    \:battle (render-battle g)))\\n\\n(defn input-start [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:world)\\n    nil))\\n\\n(defn valid-position? [x y]\\n  (not (\= (get-in @game-map [y x]) 1)))\\n\\n(defn move [p dx dy]\\n  (update-in (update-in p [\:position \:x] + dx) [\:position \:y] + dy))\\n\\n(defn move-to [p x y]\\n  (assoc-in (assoc-in p [\:position \:x] x) [\:position \:y] y))\\n\\n(defn try-battle\! [x y]\\n  (when (and (\= (get-in @game-map [y x]) 0) (> (rand 20) 15))\\n    (reset\! state \:battle)))\\n\\n(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np)\\n      (condp \=  (get-in @game-map [y x])\\n        3 (swap\! p move-to 1 2)\\n        4 (swap\! p move-to 13 7)\\n        5 (swap\! game-map (fn [m] (assoc-in m [y x] 6)))\\n        6 (swap\! game-map (fn [m] (assoc-in m [y x] 6)))\\n        (try-battle\! x y)        \\n        ))))\\n\\n(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:battle)\\n    KeyEvent/VK_UP (try-move\! player 0 -1)\\n    KeyEvent/VK_DOWN (try-move\! player 0 1)\\n    KeyEvent/VK_LEFT (try-move\! player -1 0)\\n    KeyEvent/VK_RIGHT (try-move\! player 1 0)\\n    nil))\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np)\\n      (condp \=  (get-in @game-map [y x])\\n        3 (swap\! p move-to 1 2)\\n        4 (swap\! p move-to 13 7)\\n        5 (swap\! game-map (fn [m] (assoc-in m [y x] 6)))\\n        6 (swap\! game-map (fn [m] (assoc-in m [y x] 5)))\\n        (try-battle\! x y)))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] - (get-in @player [\:stats \:atk]))))\\n                    (if (> (get-in @enemy [\:hp]) 0) \\n                      (swap\! player (fn [pl] (update-in pl [\:stats \:hp]  - (@enemy \:atk))))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] - (get-in @enemy [\:atk]))))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world)\\n      (swap\! player (fn [pl] (update-in pl [\:kills] inc))))))\\n" "(nil)\\n" ")\\n(de" "(fn)\\n" "(1)\\n" "(+)\\n" "(list)" "(list)\\n" "(when (list) 1)\\n" "(if (list) 1 0)\\n" "(if (list nil) 1 0)\\n" "(true)\\n" "(in-ns 'Test.core)\\n(defn render-stats [^Graphics2D g stats x y]\\n  (doto ^Graphics2D g\\n    (.drawString (str (stats \:name)) x y)\\n    (.drawString (str (stats \:hp)) x (+ y 20))))\\n\\n\\n(in-ns 'user)" "(in-ns 'Test.core)\\n  (-main)\\n\\n(in-ns 'user)" "(-main)\\n  " "render" "(render nil nil nil nil)\\n" "(render nil nil nil)\\n" "(render nil nil)\\n" "(render nil)\\n" "(-main)\\n  " "(in-ns 'Test.input)\\n(defn input [^KeyEvent e state game-map player enemy]\\n  (let [e (.getKeyCode e)]\\n    (condp \= @state\\n      \:start (input-start e state)\\n      \:world (input-world e state game-map player)\\n      \:battle (input-battle e state player enemy))))\\n\\n(in-ns 'Test.core)" "player" "@player" "(in-ns 'Test.input)\\n(defn move [p dx dy]\\n  (let [a (update-in (update-in p [\:position \:x] + dx) [\:position \:y] + dy)]\\n  (println a)\\n  a))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\nTest.core/player\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\n(move @Test.core/player)\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\n(move @Test.core/player 0 1)\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\n(defn move [p dx dy]\\n  (update-in (update-in p [\:position \:x] + dx) [\:position \:y] + dy))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " " (-main)\\n " "(-main)\\n  " "(+ 2 2)\\n  " "(spit \\"blubber.txt\\" \\"test\\")\\n  " "(spit \\"resourcse/blubber.txt\\" \\"test\\")" "(.exists (new java.io.File \\"resources\\"))\\n  " "(let [directory (new java.io.File \\"resources\\")]\\n    (if (.exists directory)\\n      (spit \\"resources/blubber.txt\\" \\"test\\")\\n      (.mkdirs directory)\\n      ))\\n  " "(spit \\"resources/blubber.txt\\" \\"test\\")\\n      " "(doc delete-file )\\n  " "(doc io/delete-file )\\n  " "(doc file)\\n  " "(.delete (new java.io.File \\"resources/blubber.txt\\"))\\n  " "(spit \\"resources/blubber.txt\\" \\"test\\")\\n      " "(.delete (new java.io.File \\"blubber.txt\\"))\\n  " "(.delete (new java.io.File \\"resources/\\"))\\n  " "(.delete (new java.io.File \\"resources\\"))\\n  " "(.list (new java.io.File \\"resources\\"))\\n  " "(doseq [a (.list (new java.io.File \\"resources\\"))]\\n    (println a))\\n  " "(.isDirectory (new java.io.File \\"resources\\"))\\n  " "(.list (new java.io.File \\"resources/blubber.txt\\"))\\n  " "(doseq [a (.list (new java.io.File \\"resources/blubber.txt\\"))]\\n    (println a))\\n  " "((fn remove-directory [^java.io.File directory]\\n    (doseq [file-name (.list directory)]\\n      (let [file (new java.io.File file-name) ]\\n        (if (.isDirectory file)\\n          (remove-directory file)\\n          (.delete file)))))\\n    (new java.io.File \\"resources\\"))\\n  " "((fn remove-directory [^java.io.File directory]\\n    (doseq [file-name (.list directory)]\\n      (let [file (new java.io.File file-name)]\\n        (do\\n          (println file)\\n          (if (.isDirectory file)\\n          (remove-directory file)\\n          (.delete file))))))\\n    (new java.io.File \\"resources\\"))\\n  " "(println (new java.io.File \\"resources/blubber.txt\\"))\\n  " "(.name (new java.io.File \\"resources\\"))\\n  " "(.getName (new java.io.File \\"resources\\"))\\n  " "(str (.getName (new java.io.File \\"resources\\")) \\"blubber.txt\\")\\n  " "(str (.getName (new java.io.File \\"resources\\")) \\"/\\" \\"blubber.txt\\")\\n  " "((fn remove-directory [^java.io.File directory]\\n    (let [prefix (.getName directory)]\\n      (doseq [file-name (.list directory)]\\n        (let [file (new java.io.File (str prefix \\"/\\" file-name))]\\n          (do\\n            (println file)\\n            (if (.isDirectory file)\\n              (remove-directory file)\\n              (.delete file)))))))\\n    (new java.io.File \\"resources\\"))\\n  " "(spit \\"resources/blubber.txt\\" \\"test\\")\\n      " " ((fn remove-directory [^java.io.File directory]\\n    (let [prefix (.getName directory)]\\n      (do (doseq [file-name (.list directory)]\\n        (let [file (new java.io.File (str prefix \\"/\\" file-name))]\\n          (do\\n            (println file)\\n            (if (.isDirectory file)\\n              (remove-directory file)\\n              (.delete file)))))\\n        (.delete directory))))\\n    (new java.io.File \\"resources\\"))\\n  " "(let [directory (new java.io.File \\"resources\\")]\\n    (if (.exists directory)\\n      (spit \\"resources/blubber.txt\\" \\"test\\")\\n      (do (.mkdirs directory)\\n        (spit \\"resources/blubber.txt\\" \\"test\\"))))\\n  " "(str game-map)\\n  " "(str @game-map)\\n  " "(let [directory (new java.io.File \\"resources\\")]\\n    (if (.exists directory)\\n      (spit \\"resources/blubber.txt\\" (str @game-map))\\n      (do (.mkdirs directory)\\n        (spit \\"resources/blubber.txt\\" (str @game-map)))))\\n  " "(slurp \\"resources/blubber.txt\\")\\n  " "(read-string (slurp \\"resources/blubber.txt\\"))\\n  " "(.delete (new java.io.File \\"resources/blubber.txt\\"))\\n  " "(spit \\"resources/game_map1.txt\\" (str @game-map))" "(str (fn a [] (println \\"a\\")))\\n  " "(str '(fn a [] (println \\"a\\")))\\n  " "(read-string (str '(fn a [] (println \\"a\\"))))\\n  " "(*source-path*)\\n  " "*source-path*" "(source input)\\n  " "(source-fn str)\\n  " "(doc with-out-str)\\n  " "(def content \\"(ns user) (defn foo [a b] (str a \\\\\\" \\\\\\" b))\\")\\n  " "content" "(str \\\\( content \\\\))" " (read-string (str \\\\( content \\\\)))" "(map eval (read-string (str \\\\( content \\\\))))\\n  " "(user/foo 2 3)\\n  " "(remove-ns 'user)\\n  " "(user/foo 2 3)\\n  " "content" "(ns-unmap *ns* 'content)\\n  " "content" "(slurp \\"resources/game_map.txt\\")\\n  " "(slurp \\"resources/game_map1.txt\\")\\n  " "(reset\! game-map (read-string (slurp \\"resources/game_map1.txt\\")))\\n    " "game-map" "(slurp \\"resources/game_map1.txt\\")\\n  " "(read-string (slurp \\"resources/game_map1.txt\\"))\\n  " "(doc str/replace)\\n  " "(doc clojure.string/replace)\\n  " "(str @game-map)" "(clojure.string/replace (str @game-map) \#\\"\\\\]\\" \\"]\\\\n\\")\\n  "]
eclipse.preferences.version=1
