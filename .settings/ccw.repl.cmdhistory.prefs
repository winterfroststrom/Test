cmdhistory=["(-main nil)\\n  " "(defn render-start [^Graphics2D g]\\n  (doto g\\n    (.setColor Color/BLACK)\\n    (.fillRect 0 0 500 500)\\n    (.setColor Color/RED)\\n    (.drawString \\"Alter\\" 200 100)))\\n" "(defn render-start [^Graphics2D g]\\n  (doto g\\n    (.setColor Color/BLACK)\\n    (.fillRect 0 0 500 500)\\n    (.setColor Color/RED)\\n    (.drawString \\"Alter\\" 230 100)))\\n" "(defn input-start [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:world)))\\n\\n(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:start)))\\n\\n(defn input [^KeyEvent e]\\n  (let [e (.getKeyCode e)]\\n    (condp \= @state\\n      \:start (input-start e)\\n      \:world (input-world e))))\\n" "(defn render-start [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (.setColor Color/BLACK)\\n    (.fillRect 0 0 500 500)\\n    (.setColor Color/RED)\\n    (.drawString \\"Alter\\" 230 100)))\\n" "(defn render-world [^Graphics2D g]\\n  (.clearRect g 0 0 500 500)\\n  (doseq [y (range (count game-map))]\\n    (doseq [x (range (count (game-map 0)))]\\n      (render-tile g (get-in game-map [y x]) \\n                   (* x (tile-dimensions \:x))\\n                   (* y (tile-dimensions \:y))))))\\n" "(defn render-world\\n  ([^Graphics2D g] (render-world g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (+ (* x (tile-dimensions \:x)) offx)\\n                     (+ (* y (tile-dimensions \:y)) offy))))))\\n" "(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g 100 100)\\n    \:battle (render-battle g)))\\n" "(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g 130 130)\\n    \:battle (render-battle g)))\\n" "(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g 160 160)\\n    \:battle (render-battle g)))\\n" "(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g 170 170)\\n    \:battle (render-battle g)))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (+ (* x (tile-dimensions \:x)) offx)\\n                     (+ (* y (tile-dimensions \:y)) offy))))))\\n\\n(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170))))\\n  \\n(defn render-battle [^Graphics2D g]\\n  )\\n\\n(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g)\\n    \:battle (render-battle g)))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 110))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 10))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 110))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170))))\\n" "(defn render-tile-rect [^Graphics2D g tile x y color]\\n  (doto g\\n    (.setColor color)\\n    (.fillRect x y (tile-dimensions \:x) (tile-dimensions \:y))))\\n\\n(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)))\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/RED)\\n    1 (render-tile-rect g tile x y Color/GRAY)))\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render -1 100 100)\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      ;(render -1 100 100)\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-tile -1 100 100)\\n      (render-game-map 170 170))))\\n" "(defn render-world\\n  ([^Graphics2D g] \\n    (doto g\\n      (render-game-map 170 170)\\n      (render-tile -1 100 100))))\\n" "(defn tile-position [pos keyword offset]\\n  (+ (* pos (tile-dimensions keyword)) offset))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n" "(defn render-world [^Graphics2D g]\\n  (let [offx 170 offy 170\\n        px (get-in @player [\:position \:x])\\n        py (get-in @player [\:position \:y])]\\n    (doto g\\n      (render-game-map offx offy)\\n      (render-tile -1 \\n                   (tile-position px \:x offx)\\n                   (tile-position py \:y offy)))))\\n" "(update-in @player [\:position \:x] inc)\\n" "(update-in @player [\:position \:x] dec)" "(update-in @player [\:position \:x] dec)\\n" "(defn move [p dx dy]\\n  (comp\\n    (update-in p [\:position \:y] + dy)\\n    (update-in p [\:position \:x] + dx)))\\n" "(move @player 1 1)\\n" "(doc comp)\\n" "(defn move [p dx dy]\\n  (update-in (update-in p [\:position \:x] + dx) [\:position \:y] + dy))\\n\\n(move @player 1 1)\\n" "(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:battle)\\n    KeyEvent/VK_UP (swap\! player move 0 1)\\n    KeyEvent/VK_DOWN (swap\! player move 0 -1)\\n    KeyEvent/VK_LEFT (swap\! player move -1 0)\\n    KeyEvent/VK_RIGHT (swap\! player move 1 0)))\\n" "(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:battle)\\n    KeyEvent/VK_UP (swap\! player move 0 -1)\\n    KeyEvent/VK_DOWN (swap\! player move 0 1)\\n    KeyEvent/VK_LEFT (swap\! player move 1 0)\\n    KeyEvent/VK_RIGHT (swap\! player move -1 0)))\\n" "(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:battle)\\n    KeyEvent/VK_UP (swap\! player move 0 -1)\\n    KeyEvent/VK_DOWN (swap\! player move 0 1)\\n    KeyEvent/VK_LEFT (swap\! player move -1 0)\\n    KeyEvent/VK_RIGHT (swap\! player move 1 0)))\\n" "(def time-delta 200)\\n" "(def time-delta 50)\\n" "(def time-delta 500)\\n" "(def time-delta 1000)\\n" "(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)))\\n" "(def enemey (atom {\:hp 2 \:atk 1}))\\n" "(def player (atom {\:position {\:x 2 \:y 2}\\n                   \:kills 0\\n                   \:stats {\:hp 10 \:atk 2 \:name \:player}}))\\n\\n(def enemey (atom {\:hp 2 \:atk 1 \:name \:enemy}))\\n" "(defn render-stats [^Graphics2D g stats x y]\\n  (doto g\\n    (.drawString (str (stats \:name)) x y)\\n    (.drawString (str (stats \:hp)) x (+ y 20))))\\n\\n(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (@player \:stats) 100 100)\\n    (render-stats @enemy 300 300)))\\n" "(def enemey (atom {\:hp 2 \:atk 1 \:name \:enemy}))\\n" "@enemy" "enemy" "(def enemy (atom {\:hp 2 \:atk 1 \:name \:enemy}))\\n" "(defn render-stats [^Graphics2D g stats x y]\\n  (doto g\\n    (.drawString (str (stats \:name)) x y)\\n    (.drawString (str (stats \:hp)) x (+ y 20))))\\n\\n(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (@player \:stats) 100 100)\\n    (render-stats @enemy 300 300)))\\n" "(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (@player \:stats) 100 100)\\n    (render-stats @enemy 300 100)))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [e] (update-in e [\:hp] dec)))))\\n" "enemy" "((fn [e] (update-in e [\:hp] dec)) @enemy)\\n" "(swap\! enemy (fn [e] (update-in e [\:hp] dec)))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n    ))\\n" "(defn input [^KeyEvent e]\\n  (let [e (.getKeyCode e)]\\n    (condp \= @state\\n      \:start (input-start e)\\n      \:world (input-world e)\\n      \:battle (input-battle e))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n    ))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] dec)))\\n    ))\\n" "(reset\! enemy (make-enemy))" "(defn make-enemy []\\n  {\:hp 2 \:atk 1 \:name \:enemy})\\n" "(reset\! enemy (make-enemy))" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:start)\\n    KeyEvent/VK_A (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] dec)))\\n    )\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) (reset\! state \:start)\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy)) \\n      (reset\! state \:world))))\\n" "(-main)\\n  " "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)]\\n    (if (valid-position? (get-in np [\:position \:x]) (get-in np [\:position \:y]))\\n      (reset\! p np))))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 0 0 0 0 0 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 0 0 1 1 0 0 0 1]])\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 0 0 0 0 0 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 0 0 0 1]])\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 0 0 0 0 0 0 0 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)]\\n    (when (valid-position? (get-in np [\:position \:x]) (get-in np [\:position \:y]))\\n      (reset\! p np)\\n      (when (> (rand 20) 15)\\n        (reset\! state \:battle)))))\\n" "(defn valid-position? [x y]\\n  (not (\= (get-in game-map [y x]) 1)))\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)))\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)\\n    nil))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 0 0 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn try-battle\! [x y]\\n  (when (and (\= (get-in game-map [y x]) 0) (> (rand 20) 15))\\n    (reset\! state \:battle)))\\n\\n(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? )\\n      (reset\! p np x y)\\n      (try-battle\! x y))))\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np x y)\\n      (try-battle\! x y))))\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np)\\n      (try-battle\! x y))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] dec)))\\n                    (swap\! player (fn [pl] (update-in pl [\:stats \:hp] dec))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] dec)))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] - (get-in @player [\:stats \:atk]))))\\n                    (swap\! player (fn [pl] (update-in pl [\:stats \:hp]  - (@enemy \:atk)))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] - (get-in @enemy [\:stats \:atk]))))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] - (get-in @player [\:stats \:atk]))))\\n                    (swap\! player (fn [pl] (update-in pl [\:stats \:hp]  - (@enemy \:atk)))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] - (get-in @enemy [\:atk]))))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] - (get-in @player [\:stats \:atk]))))\\n                    (swap\! player (fn [pl] (update-in pl [\:stats \:hp]  - (@enemy \:atk)))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] - (get-in @enemy [\:atk]))))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world)\\n      (swap\! player (fn [pl] (update-in pl [\:kills] inc))))))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (.drawString (str \\"Kills\: \\" (@player \:kills)) 100 100)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (.drawString g (str \\"Kills\: \\" (@player \:kills)) 100 100)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n" "(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (.drawString g (str \\"Hp\: \\" (get-in @player [\:stats \:hp])) 100 100)\\n    (.drawString g (str \\"Kills\: \\" (@player \:kills)) 100 120)\\n    (doseq [y (range (count game-map))]\\n      (doseq [x (range (count (game-map 0)))]\\n        (render-tile g (get-in game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 1]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 3]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)\\n    3 (render-tile-rect g tile x y Color/ORANGE)\\n    nil))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [3 2 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 3]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)\\n    3 (render-tile-rect g tile x y Color/ORANGE)\\n    4 (render-tile-rect g tile x y Color/ORANGE)\\n    nil))\\n" "(def game-map [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [4 2 2 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 3]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]])\\n" "(defn move-to [p x y]\\n  (assoc-in (assoc-in p [\:position \:x] x) [\:position \:y] y))\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np)\\n      (cond \\n        (\= (get-in game-map [y x]) 3) (swap\! p move-to 1 2)\\n        (\= (get-in game-map [y x]) 4) (swap\! p move-to 13 7)\\n        \:else (try-battle\! x y)        \\n        ))))\\n" "(def game-map (atom [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\\n               [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1]\\n               [4 2 2 0 1 1 0 0 0 1 1 0 5 0 1]\\n               [1 0 2 2 1 1 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 2 2 2 2 2 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 0 1 1 0 0 0 1]\\n               [1 0 0 0 1 1 0 2 2 2 2 2 2 2 3]\\n               [1 0 0 0 0 0 0 0 0 1 1 0 0 0 1]\\n               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]]))\\n\\n(defn render-start [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (.setColor Color/BLACK)\\n    (.fillRect 0 0 500 500)\\n    (.setColor Color/RED)\\n    (.drawString \\"Alter\\" 230 100)))\\n\\n(defn render-tile-rect [^Graphics2D g tile x y color]\\n  (doto g\\n    (.setColor color)\\n    (.fillRect x y (tile-dimensions \:x) (tile-dimensions \:y))))\\n\\n(defn render-tile [^Graphics2D g tile x y]\\n  (condp \= tile\\n    -1 (render-tile-rect g tile x y Color/BLUE)\\n    0 (render-tile-rect g tile x y Color/GREEN)\\n    1 (render-tile-rect g tile x y Color/GRAY)\\n    2 (render-tile-rect g tile x y Color/YELLOW)\\n    3 (render-tile-rect g tile x y Color/ORANGE)\\n    4 (render-tile-rect g tile x y Color/ORANGE)\\n    5 (render-tile-rect g tile x y Color/BLACK)\\n    6 (render-tile-rect g tile x y Color/WHITE)\\n    nil))\\n\\n(defn tile-position [pos keyword offset]\\n  (+ (* pos (tile-dimensions keyword)) offset))\\n\\n(defn render-game-map\\n  ([^Graphics2D g] (render-game-map g 0 0))\\n  ([^Graphics2D g offx offy]\\n    (.clearRect g 0 0 500 500)\\n    (.drawString g (str \\"Hp\: \\" (get-in @player [\:stats \:hp])) 100 100)\\n    (.drawString g (str \\"Kills\: \\" (@player \:kills)) 100 120)\\n    (doseq [y (range (count @game-map))]\\n      (doseq [x (range (count (@game-map 0)))]\\n        (render-tile g (get-in @game-map [y x]) \\n                     (tile-position x \:x offx)\\n                     (tile-position y \:y offy))))))\\n\\n(defn render-world [^Graphics2D g]\\n  (let [offx 170 offy 170\\n        px (get-in @player [\:position \:x])\\n        py (get-in @player [\:position \:y])]\\n    (doto g\\n      (render-game-map offx offy)\\n      (render-tile -1 \\n                   (tile-position px \:x offx)\\n                   (tile-position py \:y offy)))))\\n  \\n(defn render-stats [^Graphics2D g stats x y]\\n  (doto g\\n    (.drawString (str (stats \:name)) x y)\\n    (.drawString (str (stats \:hp)) x (+ y 20))))\\n\\n(defn render-battle [^Graphics2D g]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (@player \:stats) 100 100)\\n    (render-stats @enemy 300 100)))\\n\\n(defn render [^Graphics2D g]\\n  (condp \= @state\\n    \:start (render-start g)\\n    \:world (render-world g)\\n    \:battle (render-battle g)))\\n\\n(defn input-start [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE (reset\! state \:world)\\n    nil))\\n\\n(defn valid-position? [x y]\\n  (not (\= (get-in @game-map [y x]) 1)))\\n\\n(defn move [p dx dy]\\n  (update-in (update-in p [\:position \:x] + dx) [\:position \:y] + dy))\\n\\n(defn move-to [p x y]\\n  (assoc-in (assoc-in p [\:position \:x] x) [\:position \:y] y))\\n\\n(defn try-battle\! [x y]\\n  (when (and (\= (get-in @game-map [y x]) 0) (> (rand 20) 15))\\n    (reset\! state \:battle)))\\n\\n(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np)\\n      (condp \=  (get-in @game-map [y x])\\n        3 (swap\! p move-to 1 2)\\n        4 (swap\! p move-to 13 7)\\n        5 (swap\! game-map (fn [m] (assoc-in m [y x] 6)))\\n        6 (swap\! game-map (fn [m] (assoc-in m [y x] 6)))\\n        (try-battle\! x y)        \\n        ))))\\n\\n(defn input-world [e]\\n  (condp \= e \\n    KeyEvent/VK_SPACE (reset\! state \:battle)\\n    KeyEvent/VK_UP (try-move\! player 0 -1)\\n    KeyEvent/VK_DOWN (try-move\! player 0 1)\\n    KeyEvent/VK_LEFT (try-move\! player -1 0)\\n    KeyEvent/VK_RIGHT (try-move\! player 1 0)\\n    nil))\\n" "(defn try-move\! [p dx dy]\\n  (let [np (move @p dx dy)\\n        x (get-in np [\:position \:x])\\n        y (get-in np [\:position \:y])]\\n    (when (valid-position? x y)\\n      (reset\! p np)\\n      (condp \=  (get-in @game-map [y x])\\n        3 (swap\! p move-to 1 2)\\n        4 (swap\! p move-to 13 7)\\n        5 (swap\! game-map (fn [m] (assoc-in m [y x] 6)))\\n        6 (swap\! game-map (fn [m] (assoc-in m [y x] 5)))\\n        (try-battle\! x y)))))\\n" "(defn input-battle [e]\\n  (condp \= e\\n    KeyEvent/VK_SPACE \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    KeyEvent/VK_A (do (swap\! enemy (fn [en] (update-in en [\:hp] - (get-in @player [\:stats \:atk]))))\\n                    (if (> (get-in @enemy [\:hp]) 0) \\n                      (swap\! player (fn [pl] (update-in pl [\:stats \:hp]  - (@enemy \:atk))))))\\n    KeyEvent/VK_S (swap\! player (fn [pl] (update-in pl [\:stats \:hp] - (get-in @enemy [\:atk]))))\\n    nil)\\n  (cond \\n    (< (get-in @player [\:stats \:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! player (make-player))\\n      (reset\! state \:start))\\n    (< (get-in @enemy [\:hp]) 1) \\n    (do (reset\! enemy (make-enemy))\\n      (reset\! state \:world)\\n      (swap\! player (fn [pl] (update-in pl [\:kills] inc))))))\\n" "(nil)\\n" ")\\n(de" "(fn)\\n" "(1)\\n" "(+)\\n" "(list)" "(list)\\n" "(when (list) 1)\\n" "(if (list) 1 0)\\n" "(if (list nil) 1 0)\\n" "(true)\\n" "(in-ns 'Test.core)\\n(defn render-stats [^Graphics2D g stats x y]\\n  (doto ^Graphics2D g\\n    (.drawString (str (stats \:name)) x y)\\n    (.drawString (str (stats \:hp)) x (+ y 20))))\\n\\n\\n(in-ns 'user)" "(in-ns 'Test.core)\\n  (-main)\\n\\n(in-ns 'user)" "(-main)\\n  " "render" "(render nil nil nil nil)\\n" "(render nil nil nil)\\n" "(render nil nil)\\n" "(render nil)\\n" "(-main)\\n  " "(in-ns 'Test.input)\\n(defn input [^KeyEvent e state game-map player enemy]\\n  (let [e (.getKeyCode e)]\\n    (condp \= @state\\n      \:start (input-start e state)\\n      \:world (input-world e state game-map player)\\n      \:battle (input-battle e state player enemy))))\\n\\n(in-ns 'Test.core)" "player" "@player" "(in-ns 'Test.input)\\n(defn move [p dx dy]\\n  (let [a (update-in (update-in p [\:position \:x] + dx) [\:position \:y] + dy)]\\n  (println a)\\n  a))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\nTest.core/player\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\n(move @Test.core/player)\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\n(move @Test.core/player 0 1)\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\n(defn move [p dx dy]\\n  (update-in (update-in p [\:position \:x] + dx) [\:position \:y] + dy))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " " (-main)\\n " "(-main)\\n  " "(+ 2 2)\\n  " "(spit \\"blubber.txt\\" \\"test\\")\\n  " "(spit \\"resourcse/blubber.txt\\" \\"test\\")" "(.exists (new java.io.File \\"resources\\"))\\n  " "(let [directory (new java.io.File \\"resources\\")]\\n    (if (.exists directory)\\n      (spit \\"resources/blubber.txt\\" \\"test\\")\\n      (.mkdirs directory)\\n      ))\\n  " "(spit \\"resources/blubber.txt\\" \\"test\\")\\n      " "(doc delete-file )\\n  " "(doc io/delete-file )\\n  " "(doc file)\\n  " "(.delete (new java.io.File \\"resources/blubber.txt\\"))\\n  " "(spit \\"resources/blubber.txt\\" \\"test\\")\\n      " "(.delete (new java.io.File \\"blubber.txt\\"))\\n  " "(.delete (new java.io.File \\"resources/\\"))\\n  " "(.delete (new java.io.File \\"resources\\"))\\n  " "(.list (new java.io.File \\"resources\\"))\\n  " "(doseq [a (.list (new java.io.File \\"resources\\"))]\\n    (println a))\\n  " "(.isDirectory (new java.io.File \\"resources\\"))\\n  " "(.list (new java.io.File \\"resources/blubber.txt\\"))\\n  " "(doseq [a (.list (new java.io.File \\"resources/blubber.txt\\"))]\\n    (println a))\\n  " "((fn remove-directory [^java.io.File directory]\\n    (doseq [file-name (.list directory)]\\n      (let [file (new java.io.File file-name) ]\\n        (if (.isDirectory file)\\n          (remove-directory file)\\n          (.delete file)))))\\n    (new java.io.File \\"resources\\"))\\n  " "((fn remove-directory [^java.io.File directory]\\n    (doseq [file-name (.list directory)]\\n      (let [file (new java.io.File file-name)]\\n        (do\\n          (println file)\\n          (if (.isDirectory file)\\n          (remove-directory file)\\n          (.delete file))))))\\n    (new java.io.File \\"resources\\"))\\n  " "(println (new java.io.File \\"resources/blubber.txt\\"))\\n  " "(.name (new java.io.File \\"resources\\"))\\n  " "(.getName (new java.io.File \\"resources\\"))\\n  " "(str (.getName (new java.io.File \\"resources\\")) \\"blubber.txt\\")\\n  " "(str (.getName (new java.io.File \\"resources\\")) \\"/\\" \\"blubber.txt\\")\\n  " "((fn remove-directory [^java.io.File directory]\\n    (let [prefix (.getName directory)]\\n      (doseq [file-name (.list directory)]\\n        (let [file (new java.io.File (str prefix \\"/\\" file-name))]\\n          (do\\n            (println file)\\n            (if (.isDirectory file)\\n              (remove-directory file)\\n              (.delete file)))))))\\n    (new java.io.File \\"resources\\"))\\n  " "(spit \\"resources/blubber.txt\\" \\"test\\")\\n      " " ((fn remove-directory [^java.io.File directory]\\n    (let [prefix (.getName directory)]\\n      (do (doseq [file-name (.list directory)]\\n        (let [file (new java.io.File (str prefix \\"/\\" file-name))]\\n          (do\\n            (println file)\\n            (if (.isDirectory file)\\n              (remove-directory file)\\n              (.delete file)))))\\n        (.delete directory))))\\n    (new java.io.File \\"resources\\"))\\n  " "(let [directory (new java.io.File \\"resources\\")]\\n    (if (.exists directory)\\n      (spit \\"resources/blubber.txt\\" \\"test\\")\\n      (do (.mkdirs directory)\\n        (spit \\"resources/blubber.txt\\" \\"test\\"))))\\n  " "(str game-map)\\n  " "(str @game-map)\\n  " "(let [directory (new java.io.File \\"resources\\")]\\n    (if (.exists directory)\\n      (spit \\"resources/blubber.txt\\" (str @game-map))\\n      (do (.mkdirs directory)\\n        (spit \\"resources/blubber.txt\\" (str @game-map)))))\\n  " "(slurp \\"resources/blubber.txt\\")\\n  " "(read-string (slurp \\"resources/blubber.txt\\"))\\n  " "(.delete (new java.io.File \\"resources/blubber.txt\\"))\\n  " "(spit \\"resources/game_map1.txt\\" (str @game-map))" "(str (fn a [] (println \\"a\\")))\\n  " "(str '(fn a [] (println \\"a\\")))\\n  " "(read-string (str '(fn a [] (println \\"a\\"))))\\n  " "(*source-path*)\\n  " "*source-path*" "(source input)\\n  " "(source-fn str)\\n  " "(doc with-out-str)\\n  " "(def content \\"(ns user) (defn foo [a b] (str a \\\\\\" \\\\\\" b))\\")\\n  " "content" "(str \\\\( content \\\\))" " (read-string (str \\\\( content \\\\)))" "(map eval (read-string (str \\\\( content \\\\))))\\n  " "(user/foo 2 3)\\n  " "(remove-ns 'user)\\n  " "(user/foo 2 3)\\n  " "content" "(ns-unmap *ns* 'content)\\n  " "content" "(slurp \\"resources/game_map.txt\\")\\n  " "(slurp \\"resources/game_map1.txt\\")\\n  " "(reset\! game-map (read-string (slurp \\"resources/game_map1.txt\\")))\\n    " "game-map" "(slurp \\"resources/game_map1.txt\\")\\n  " "(read-string (slurp \\"resources/game_map1.txt\\"))\\n  " "(doc str/replace)\\n  " "(doc clojure.string/replace)\\n  " "(str @game-map)" "(clojure.string/replace (str @game-map) \#\\"\\\\]\\" \\"]\\\\n\\")\\n  " "(read-string (slurp \\"resources/game_map1.txt\\"))" "(def enemy-table (atom nil))\\n" "enemy" "{^{\:type 3} \:e 2}\\n" "{ ^{\:type 3} \:e 2}\\n" "{ \:e 2}\\n" "(with-meta { \:e 2} {\:type 3})\\n" "(meta (with-meta { \:e 2} {\:type 3}))\\n" "(str (with-meta { \:e 2} {\:type 3}))\\n" "(let [a (with-meta { \:e 2} {\:type 3})]\\n(str 'with-meta (str a) (str (meta a))))\\n" "(let [a (with-meta { \:e 2} {\:type 3})]\\n(str '(with-meta (str a) (str (meta a)) )))\\n" "(let [a (with-meta { \:e 2} {\:type 3})]\\n(str '(with-meta ~(str a) ~(str (meta a)) )))\\n" "(let [a (with-meta { \:e 2} {\:type 3})]\\n  (str \\"(with-meta\\" ~(str a) ~(str (meta a)) \\")\\"))\\n" "(let [a (with-meta { \:e 2} {\:type 3})]\\n  (str \\"(with-meta \\" ~(str a) ~(str (meta a)) \\")\\"))\\n" "(let [a (with-meta { \:e 2} {\:type 3})]\\n  (str \\"(with-meta \\" (str a) (str (meta a)) \\")\\"))\\n" "(read-string (let [a (with-meta { \:e 2} {\:type 3})]\\n  (str \\"(with-meta \\" (str a) (str (meta a)) \\")\\")))\\n" "(eval (let [a (with-meta { \:e 2} {\:type 3})]\\n  (str \\"(with-meta \\" (str a) (str (meta a)) \\")\\")))\\n" "(eval (read-string (let [a (with-meta { \:e 2} {\:type 3})]\\n  (str \\"(with-meta \\" (str a) (str (meta a)) \\")\\"))))\\n" "(meta (eval (read-string (let [a (with-meta { \:e 2} {\:type 3})]\\n  (str \\"(with-meta \\" (str a) (str (meta a)) \\")\\")))))\\n" "(in-ns 'Test.game)\\n(reduce + [.8 .2])\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(reduce + [0.8 0.2])\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(rand 1.0)\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defmulti make-enemy (fn [table spawns] (type-dispatch spawns)))\\n\\n(defmethod make-enemy \:probabilities [table spawns]\\n  (let [probabilities (spawns \:probabilities)\\n        sum (reduce + probabilities)\\n        place (rand sum)]\\n    (loop [place place index 0]\\n      (let [probability (probabilities index)]\\n        (if (> probability place)\\n          (table index)\\n          (recur (- place probability) (inc index)))))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(def type-dispatch [x] (x \:type))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defmulti make-enemy (fn [table spawns] (type-dispatch spawns)))\\n\\n(defmethod make-enemy \:probabilities [table spawns]\\n  (let [probabilities (spawns \:probabilities)\\n        sum (reduce + probabilities)\\n        place (rand sum)]\\n    (loop [place place index 0]\\n      (let [probability (probabilities index)]\\n        (if (> probability place)\\n          (table index)\\n          (recur (- place probability) (inc index)))))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defn type-dispatch [x] (x \:type))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defmulti make-enemy (fn [table spawns] (type-dispatch spawns)))\\n\\n(defmethod make-enemy \:probabilities [table spawns]\\n  (let [probabilities (spawns \:probabilities)\\n        sum (reduce + probabilities)\\n        place (rand sum)]\\n    (loop [place place index 0]\\n      (let [probability (probabilities index)]\\n        (if (> probability place)\\n          (table index)\\n          (recur (- place probability) (inc index)))))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(make-enemy [9 3 5] {\:type \:probabilities \:probabilities [0.3 0.0 0.7]})\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(make-enemy [9 3 5] {\:type \:probabilities \:probabilities [0.1 0.0 0.9]})\\n\\n(in-ns 'Test.core)" "(def game-map (atom nil))\\n(def enemy-table (atom nil))\\n(def spawns (atom nil))\\n" "(defn create-key-adapter []\\n  (proxy [KeyAdapter] []\\n    (keyReleased [^KeyEvent e] \\n                 (input {\:event (.getKeyCode e) \\n                         \:state state\\n                         \:game-map game-map \\n                         \:player player\\n                         \:enemy enemy\\n                         \:enemies enemy-table\\n                         \:spawns spawns}))))\\n" "(in-ns 'Test.input)\\n(defn input-world [params]\\n  (condp \= (params \:event) \\n    KeyEvent/VK_SPACE \\n    (do (reset\! (params \:state) \:battle)\\n      (reset\! (params \:enemy) (Test.game/make-enemy (params \:enemies \:spawns))))\\n    KeyEvent/VK_UP (try-move\! params 0 -1)\\n    KeyEvent/VK_DOWN (try-move\! params 0 1)\\n    KeyEvent/VK_LEFT (try-move\! params -1 0)\\n    KeyEvent/VK_RIGHT (try-move\! params 1 0)\\n    nil))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " "(read-string (slurp \\"resources/game_map1.txt\\"))" "(-main)\\n  " "  (-main)\\n" "(-main)\\n  " "(in-ns 'Test.render)\\n(defn render-battle [^Graphics2D g player enemy]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (player \:stats) 100 100)\\n    (render-stats enemy 300 100)))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " "(defn animation [_]\\n  (when running\\n    (send-off *agent* \#'animation))\\n  (.repaint ^JPanel @panel)\\n  (println \\"sdf\\")\\n  (Thread/sleep time-delta)\\n  nil)\\n" "(-main)\\n  " "(defn -main [& args]\\n  (reset\! panel (create-panel))\\n  (reset\! ka (create-key-adapter))\\n  (reset\! frame (SwingUtilities/invokeLater create-frame))\\n  ;(send-off animator animation)\\n  )\\n" "  (-main)\\n" "@running" "running" "(def running (atom true))\\n" "true" "(atom true)" "(reset\! @running true)\\n  " "@running" "(nil \:type)\\n" "(def tiles [{\:type \:battle}\\n            {\:type \:invalid}\\n            {\:type \:none}\\n            {\:type \:move \:x 1 \:y 2}\\n            {\:type \:move \:x 13 \:y 7}\\n            {\:type \:replace \:target \:self \:data 6}\\n            {\:type \:replace \:target \:self \:data 5}])\\n" "(-main)\\n  " "(in-ns 'Test.game)\\n(def tiles [{\:type \:battle}\\n            {\:type \:invalid}\\n            {\:type \:none}\\n            {\:type \:move-to \:target \:player \:x 1 \:y 2}\\n            {\:type \:move-to \:target \:player \:x 13 \:y 7}\\n            {\:type \:replace \:target \:self \:data 6}\\n            {\:type \:replace \:target \:self \:data 5}])\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defmethod tile-action\! \:move-to [params tile instance]\\n  (dosync \\n    (let [target (params (tile \:target))\\n          x (and (tile \:x) (instance \:x)) \\n          y (and (tile \:y) (instance \:y))]\\n      (println target x y)\\n      (alter target move-to x y))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defmethod tile-action\! \:move-to [params tile instance]\\n  (dosync \\n    (let [target (params (tile \:target))\\n          x (and (tile \:x) (instance \:x)) \\n          y (and (tile \:y) (instance \:y))]\\n      (alter target move-to x y))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defmethod tile-action\! \:default [params tile instance]\\n  )\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defn do-tile\! [params x y]\\n  (let [index (and (get-in @(params \:game-map) [y x]) {\:type \:none})]\\n    (tile-action\! params (tiles index) {\:x x \:y y})))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defn do-tile\! [params x y]\\n  (let [index (and (get-in @(params \:game-map) [y x]) 1)]\\n    (tile-action\! params (tiles index) {\:x x \:y y})))\\n\\n(in-ns 'Test.core)" "game-map" "(get-in game-map [20])\\n" "(get-in game-map [20 20])\\n" "(and (get-in game-map [20 20]) 1)\\n" "(and 1)\\n" "(and 1 nil)\\n" "(and nil 1)\\n" "(in-ns 'Test.game)\\n(defn do-tile\! [params x y]\\n  (let [t (get-in @(params \:game-map) [y x])\\n        index (if t t 1)]\\n    (tile-action\! params (tiles index) {\:x x \:y y})))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defmethod tile-action\! \:move-to [params tile instance]\\n  (dosync \\n    (let [target (params \:player)\\n          x (if (tile \:x) (tile \:x) (instance \:x)) \\n          y (if (tile \:y) (tile \:y) (instance \:y))]\\n      (alter target move-to x y))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defn do-tile\! [params x y]\\n  (tile-action\! params (tiles (or (get-in @(params \:game-map) [y x]) 1)) {\:x x \:y y}))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n(defmethod tile-action\! \:move-to [params tile instance]\\n  (dosync \\n    (let [target (params \:player)\\n          x (or (tile \:x) (instance \:x)) \\n          y (or (tile \:y) (instance \:y))]\\n      (alter target move-to x y))))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " "(in-ns 'Test.game)\\n(defn valid-position? [params x y]\\n  (let [index (or (get-in @(params \:game-map) [y x]) 1)]\\n    (not (\= ((get-in @(params \:tile-types) [index]) \:type) \:invalid))))\\n\\n(in-ns 'Test.core)" "  (-main)\\n" "(-main)\\n  " "(in-ns 'Test.game)\\n(defmethod tile-action\! \:move-to [params tile instance]\\n  (dosync \\n    (let [target (params \:player)\\n          x (or (tile \:x) (instance \:x)) \\n          y (or (tile \:y) (instance \:y))]\\n      (alter target move-to x y)\\n      (do-tile\! params x y))))\\n\\n(in-ns 'Test.core)" "  (-main)\\n" "(in-ns 'Test.game)\\n(defmethod tile-action\! \:move-to [params tile instance]\\n  (dosync \\n    (let [target (params \:player)\\n          x (or (tile \:x) (instance \:x)) \\n          y (or (tile \:y) (instance \:y))]\\n      (alter target move-to x y)\\n      (do-tile\! params))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game)\\n\\n(defmethod tile-action\! \:move-to [params tile instance]\\n  (dosync \\n    (let [target (params \:player)\\n          x (or (tile \:x) (instance \:x)) \\n          y (or (tile \:y) (instance \:y))]\\n      (alter target move-to x y)\\n      (do-tile\! params x y))))\\n\\n(in-ns 'Test.core)" "(flat-world-map 1 1 1)\\n" "(flat-world-map 1 1 2)\\n" "(defn flat-world-map [number width height]\\n  (vec (take height (repeat (vec (take width (repeat number)))))))\\n" "(flat-world-map 1 1 2)\\n" "(flat-world-map 1 2 2)\\n" "(flat-world-map 0 2 2)\\n" "(defn init-vec [size value]\\n  (vec (take size (repeat value))))\\n\\n(defn flat-world-map [number width height]\\n  (init-vec height (init-vec width number)))\\n" "(flat-world-map 0 2 2)" "(defn add-border [map border]\\n  (map (fn [_] border) (first map)))\\n\\n(add-border (flat-world-map 0 2 2) 2)\\n" "(flat-world-map 0 2 2)" "(first (flat-world-map 0 2 2))\\n" "(map (fn [%] border) (first (flat-world-map 0 2 2)))\\n" "(map (fn [%] 3) (first (flat-world-map 0 2 2)))\\n" "(mapv (fn [%] 3) (first (flat-world-map 0 2 2)))\\n" "(defn add-border [world border]\\n  (map (fn [_] border) (first world)))\\n" "(add-border (flat-world-map 0 2 2) 2)\\n" "(defn add-border [world border]\\n  (mapv (fn [_] border) (first world)))\\n" "(add-border (flat-world-map 0 2 2) 2)\\n" "(defn add-border [world border]\\n  (assoc world 0 (mapv (fn [_] border) (first world))))\\n" "(add-border (flat-world-map 0 2 2) 2)\\n" "(defn replace-row [world replacement index]\\n  (assoc world index (mapv (fn [_] replacement) (nth world index))))\\n" "(defn replace-column \\n  ([world replacement index]\\n    (replace-column world replacement index 0))\\n  ([world replacement index row-index]\\n    (if (>\= row-index (count world))\\n      world\\n      (recur (assoc world row-index (assoc (world row-index) index replacement)) replacement index (dec row-index)))))\\n" "(replace-column (flat-world-map 0 2 2) 2)\\n" "(replace-column (flat-world-map 0 2 2) 2 0)\\n" "(assoc world 0 (assoc ((flat-world-map 0 2 2) 0) 0 2))\\n" "(assoc (flat-world-map 0 2 2) 0 (assoc ((flat-world-map 0 2 2) 0) 0 2))\\n" "(assoc (flat-world-map 0 2 2) 0 (assoc ((flat-world-map 0 2 2) 1) 1 2))\\n" "(assoc (flat-world-map 0 2 2) 1 (assoc ((flat-world-map 0 2 2) 1) 0 2))\\n" "(replace-column (flat-world-map 0 2 2) 2 0)\\n" "(defn replace-column \\n  ([world replacement index]\\n    (replace-column world replacement index 0))\\n  ([world replacement index row-index]\\n    (if (>\= row-index (count world))\\n      world\\n      (recur (assoc world row-index (assoc (world row-index) index replacement)) replacement index (inc row-index)))))\\n" "(replace-column (flat-world-map 0 2 2) 2 0)\\n" "(deftest flat-world-map-test\\n  (testing \\"flat world creation\\"\\n    (is (\= (flat-world-map 3 3 0) [[0 0 0][0 0 0][0 0 0]]))))\\n" "(clojure.test/deftest flat-world-map-test\\n  (testing \\"flat world creation\\"\\n    (is (\= (flat-world-map 3 3 0) [[0 0 0][0 0 0][0 0 0]]))))\\n" "(clojure.test/deftest flat-world-map-test\\n  (clojure.test/testing \\"flat world creation\\"\\n    (is (\= (flat-world-map 3 3 0) [[0 0 0][0 0 0][0 0 0]]))))\\n" "(clojure.test/deftest flat-world-map-test\\n  (clojure.test/testing \\"flat world creation\\"\\n    (clojure.test/is (\= (flat-world-map 3 3 0) [[0 0 0][0 0 0][0 0 0]]))))\\n" "(defn add-border [world border]\\n  (let [start 0\\n        end (nth world (dec (count world)))]\\n  (assoc world start (mapv (fn [_] border) (nth world start)))\\n  (assoc world end (mapv (fn [_] border) (nth world end)))\\n  (replace-row world border start)\\n  ))\\n" "(defn add-border [world border]\\n  (let [start 0\\n        end (nth world (dec (count world)))]\\n    (-> world\\n      (replace-row border start)\\n      (replace-row border end)\\n      (replace-column border start)\\n      (replace-column border end))))\\n" "(add-border (flat-world-map 0 2 2) 2)\\n" "(replace-row (flat-world-map 0 3 3) 2 0)\\n" "(replace-row (flat-world-map 0 3 3) 2 1)\\n" "(replace-row (flat-world-map 0 3 3) 2 2)\\n" "(replace-column (flat-world-map 0 3 3) 2 0)\\n" "(replace-column (flat-world-map 0 3 3) 2 1)\\n" "(replace-column (flat-world-map 0 3 3) 2 2)\\n" "(defn add-border [world border]\\n  (let [start 0\\n        end (count world)]\\n    (-> world\\n      (replace-row border start)\\n      (replace-row border end)\\n      (replace-column border start)\\n      (replace-column border end))))\\n" "(nth (flat-world-map 0 3 3) )\\n" "(add-border (flat-world-map 0 2 2) 2)\\n" "(defn add-border [world border]\\n  (let [start 0\\n        end (dec (count world))]\\n    (-> world\\n      (replace-row border start)\\n      (replace-row border end)\\n      (replace-column border start)\\n      (replace-column border end))))\\n" "(add-border (flat-world-map 0 2 2) 2)\\n" "(add-border (flat-world-map 0 4 4) 2)\\n" "(defn add-border \\n  ([world border row column]\\n    (add-border world border 0 (dec (count world))))\\n  ([world border]\\n    (-> world\\n      (replace-row border start)\\n      (replace-row border end)\\n      (replace-column border start)\\n      (replace-column border end))))\\n\\n(add-border (flat-world-map 0 4 4) 2)\\n" "(defn add-border \\n  ([world border]\\n    (add-border world border 0 (dec (count world))))\\n  ([world border row column]\\n    (-> world\\n      (replace-row border row)\\n      (replace-row border column)\\n      (replace-column border row)\\n      (replace-column border column))))\\n" "(add-border (flat-world-map 0 4 4) 2)\\n" "(add-border (flat-world-map 0 4 4) 2 0 2)\\n" "(add-border (flat-world-map 0 4 4) 2)\\n" "(defn add-border [world border]\\n  (let [start 0\\n        end (dec (count world))]\\n    (-> world\\n      (replace-row border start)\\n      (replace-row border end)\\n      (replace-column border start)\\n      (replace-column border end))))\\n\\n(add-border (flat-world-map 0 4 4) 2)\\n" "(-main)\\n  " "(in-ns 'Test.render)\\n(defn render-battle [^Graphics2D g player enemy]\\n  (doto g\\n    (.clearRect 0 0 500 500)\\n    (render-stats (player \:stats) 100 100)\\n    (render-stats enemy 100 150)))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " "  (-main)\\n" "(-main)\\n  " "spawns" "enemies" "game-map" "tile-types" "spawns" "(in-ns 'Test.game.basic)\\n@Test.core/spawns\\n(in-ns 'Test.core)" "spawns" "enemies" "(-main)\\n  " "spawns" "enemies" "spawns" "(in-ns 'Test.game.world)\\n@Test.core/spawns\\n(in-ns 'Test.core)" "(in-ns 'Test.game.world)\\nTest.core/spawns\\n(in-ns 'Test.core)" "spawns" "  (-main)\\n" "spawns" "(in-ns 'Test.game.basic)\\nTest.core/spawns\\n\\n(in-ns 'Test.core)" "state" "tile-types" "game-map" "enemies" "state" "enemy" "player" "(in-ns 'Test.render)\\n(defn render [^Graphics2D g state game-map player enemy tile-renders]\\n  (println \\"dsf\\")\\n  (condp \= state\\n    \:start (render-start g)\\n    \:world (render-world g game-map player tile-renders)\\n    \:battle (render-battle g player enemy)))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.render)\\n(defn render [^Graphics2D g state game-map player enemy tile-renders]\\n  (spit \\"oas\\" 12)\\n  (condp \= state\\n    \:start (render-start g)\\n    \:world (render-world g game-map player tile-renders)\\n    \:battle (render-battle g player enemy)))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " "state" "(dosync (ref-set state \:start))\\n" "enemy" "state" "player" "game-map" "(require 'Test.game.basic)\\n" "enemies" "spawns" "(Test.game.basic/make-enemy @enemies @spawns)\\n" "enemies" "(in-ns 'Test.game.basic)\\n(defn init-battle\! [params]\\n  (dosync\\n    (println params)\\n    (ref-set (params \:state) \:battle)\\n    (ref-set (params \:enemy) (make-enemy (params \:enemies) (params \:spawns)))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game.basic)\\n(defn init-battle\! [params]\\n  (dosync\\n    (spit \\"sdf\\" (str params))\\n    (ref-set (params \:state) \:battle)\\n    (ref-set (params \:enemy) (make-enemy (params \:enemies) (params \:spawns)))))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.game.basic)\\n(defn init-battle\! [params]\\n  (dosync\\n    (ref-set (params \:state) \:battle)\\n    (ref-set (params \:enemy) (make-enemy @(params \:enemies) @(params \:spawns)))))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " "(in-ns 'Test.game)\\n(defn do-turn\! [params entity]\\n  (dosync\\n    (condp \= entity\\n      0 (battle/enemy-attack\! params)\\n      1 (battle/player-attack\! params)\\n      nil)\\n    (cond \\n      (battle/death? params) (basic/clear\! params)\\n      (battle/victory? params) (battle/win-battle\! params)\\n      \:else nil)))\\n\\n(in-ns 'Test.core)" "(def battle-state (ref nil))\\n" "(defn create-key-adapter []\\n  (proxy [KeyAdapter] []\\n    (keyReleased [^KeyEvent e] \\n                 (input {\:event (.getKeyCode e) \\n                         \:state state\\n                         \:game-map game-map \\n                         \:player player\\n                         \:enemy enemy\\n                         \:enemies enemies\\n                         \:tile-types tile-types\\n                         \:tile-renders tile-renders\\n                         \:spawns spawns\\n                         \:battle-state battle-state}))))\\n" "(in-ns 'Test.render)\\n(defn render [^Graphics2D g state game-map player enemy tile-renders battle-state]\\n  (condp \= state\\n    \:start (render-start g)\\n    \:world (render-world g game-map player tile-renders)\\n    \:battle (render-battle g player enemy)))\\n\\n(in-ns 'Test.core)" "(defn create-panel []\\n  (doto (proxy [JPanel] []\\n          (paint [^Graphics2D g] (render ^Graphics2D g @state @game-map @player @enemy @tile-renders @battle-state)))\\n    (.setPreferredSize (new Dimension 500 500))))\\n" "(in-ns 'Test.game.basic)\\n(defn init-battle\! [params]\\n  (dosync\\n    (ref-set (params \:state) \:battle)\\n    (ref-set (params \:enemy) (make-enemy @(params \:enemies) @(params \:spawns)))\\n    (ref-set (params \:battle-state) {\:turn 0})))\\n\\n(in-ns 'Test.core)" "(-main)\\n  " "(in-ns 'Test.input)\\n(defn input-battle [params]\\n  (condp \= (params \:event)\\n    KeyEvent/VK_SPACE nil;(game/clear\! params)\\n    KeyEvent/VK_A (game/do-turn\! params)\\n    KeyEvent/VK_S (game/do-turn\! params)\\n    nil))\\n\\n(in-ns 'Test.core)" "(in-ns 'Test.input)\\n(defn input-battle [params]\\n  (condp \= (params \:event)\\n    KeyEvent/VK_SPACE nil;(game/clear\! params)\\n    KeyEvent/VK_A (game/do-turn\! params)\\n    KeyEvent/VK_S nil;(game/do-turn\! params)\\n    nil))\\n\\n(in-ns 'Test.core)" "  (-main)\\n" "(-main)\\n  "]
eclipse.preferences.version=1
